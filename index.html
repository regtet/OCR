<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>OCR匹配下载工具</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .main-container {
            max-width: 100%;
            margin: 0;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 0;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        h2 {
            text-align: center;
            color: #333;
            margin: 0 0 10px 0;
            font-size: 1.5em;
            font-weight: 300;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .comparison-layout {
            display: flex;
            gap: 20px;
            flex: 1;
            min-height: 0;
        }

        .group {
            flex: 1;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
        }

        .group h3 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 1.1em;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .group h3::before {
            content: '';
            width: 3px;
            height: 16px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 2px;
        }

        label {
            font-weight: 600;
            display: block;
            margin-bottom: 15px;
            color: #495057;
            font-size: 1.1em;
        }

        input[type="file"] {
            margin-bottom: 15px;
            padding: 10px;
            border: 2px dashed #dee2e6;
            border-radius: 10px;
            background: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        input[type="file"]:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            border-radius: 10px;
            background: #fff;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            position: relative;
            min-height: 0;
            transition: all 0.3s ease;
        }

        .container.drag-over {
            background: #e3f2fd;
            border: 2px dashed #2196F3;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.3);
        }



        .container::-webkit-scrollbar {
            width: 8px;
        }

        .container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .container::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #fff;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            min-height: 350px;
            max-height: 400px;
            overflow: hidden;
        }

        .item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .item.selected {
            border-color: #FF5722;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(255, 87, 34, 0.3);
        }

        img {
            width: 100%;
            height: 200px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            object-fit: contain;
            background: #f8f9fa;
            transition: transform 0.3s ease;
            display: block;
            margin-bottom: 8px;
            cursor: pointer;
            max-width: 100%;
            max-height: 200px;
        }

        .item:hover img {
            transform: scale(1.02);
        }

        p {
            margin: 4px 0;
            font-size: 12px;
            text-align: center;
            word-break: break-word;
            color: #495057;
            line-height: 1.4;
            min-height: 35px;
            max-height: 60px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            background: #f8f9fa;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            cursor: help;
        }

        .filename {
            margin: 4px 0;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
            padding: 6px 8px;
            border-radius: 6px;
            transition: all 0.3s ease;
            word-break: break-all;
            line-height: 1.3;
            min-height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .filename.matched {
            color: #28a745;
            background: #d4edda;
        }

        .filename.unmatched {
            color: #dc3545;
            background: #f8d7da;
        }

        .name-resolution-container {
            margin: 4px 0;
            padding: 6px 8px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            font-weight: 600;
            word-break: break-all;
            line-height: 1.3;
            min-height: 35px;
        }

        .name-resolution-container.matched {
            color: #28a745;
            background: #d4edda;
        }

        .name-resolution-container.unmatched {
            color: #dc3545;
            background: #f8d7da;
        }

        .filename-text {
            flex: 1;
            text-align: left;
            margin-right: 8px;
        }

        .resolution-text {
            font-size: 10px;
            color: #6c757d;
            font-style: italic;
            font-weight: 500;
            background: rgba(255, 255, 255, 0.7);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            white-space: nowrap;
        }


        .delete-button {
            position: absolute;
            top: 6px;
            right: 6px;
            background: rgba(255, 255, 255, 0.95);
            color: #6c757d;
            border: 1px solid #dee2e6;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 15;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .item:hover .delete-button {
            display: flex;
        }

        .delete-button:hover {
            background: #dc3545;
            color: white;
            border-color: #dc3545;
            transform: scale(1.05);
        }

        .size-match-indicator {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .size-match-indicator.match {
            background: #28a745;
        }

        .size-match-indicator.no-match {
            background: #dc3545;
        }


        .confidence-score {
            font-size: 12px;
            color: #28a745;
            margin: 4px 0;
            font-weight: bold;
            text-align: center;
            background: #e8f5e8;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .confidence-score.low {
            color: #dc3545;
        }

        .confidence-score.medium {
            color: #ffc107;
        }




        .file-input-section {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
        }

        .select-btn {
            padding: 10px 20px;
            font-size: 14px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .select-btn:hover {
            background: #1976D2;
            transform: translateY(-1px);
        }

        .file-count {
            color: #6c757d;
            font-size: 14px;
            font-weight: 500;
        }

        .usage-tips {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #2196F3;
        }

        .usage-tips h4 {
            margin: 0 0 10px 0;
            color: #1976D2;
            font-size: 16px;
        }

        .usage-tips p {
            margin: 5px 0;
            color: #424242;
            font-size: 14px;
            line-height: 1.5;
        }


        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 10px 0;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .controls button:disabled:hover {
            transform: none !important;
            box-shadow: none !important;
        }

        /* 图片预览模态框样式 */
        .image-preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .image-preview-content {
            max-width: 98%;
            max-height: 98%;
            position: relative;
            cursor: default;
        }

        .image-preview-content img {
            max-width: 100%;
            max-height: 75vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .image-preview-info {
            position: absolute;
            bottom: -100px;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            max-height: 80px;
            overflow: visible;
        }

        .image-preview-info h3 {
            margin: 0 0 6px 0;
            font-size: 16px;
        }

        .image-preview-info p {
            margin: 2px 0;
            font-size: 12px;
            opacity: 0.9;
            line-height: 1.3;
        }

        .close-preview {
            position: absolute;
            top: -40px;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-preview:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        button {
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            min-width: 120px;
        }

        #startBtn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: #fff;
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
        }

        #startBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(76, 175, 80, 0.4);
        }

        #confirmBtn {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: #fff;
            box-shadow: 0 4px 8px rgba(33, 150, 243, 0.3);
            opacity: 0.5;
        }

        #confirmBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(33, 150, 243, 0.4);
        }

        #forceMatchBtn {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            color: #fff;
            box-shadow: 0 4px 8px rgba(255, 152, 0, 0.3);
            opacity: 0.5;
        }

        #forceMatchBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(255, 152, 0, 0.4);
        }

        #batchDownloadBtn {
            background: linear-gradient(45deg, #00BCD4, #0097A7);
            color: #fff;
            box-shadow: 0 4px 8px rgba(0, 188, 212, 0.3);
        }

        #batchDownloadBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 188, 212, 0.4);
        }

        #zipDownloadBtn {
            background: linear-gradient(45deg, #9C27B0, #7B1FA2);
            color: #fff;
            box-shadow: 0 4px 8px rgba(156, 39, 176, 0.3);
        }

        #zipDownloadBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(156, 39, 176, 0.4);
        }

        #resetBtn {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: #fff;
            box-shadow: 0 4px 8px rgba(244, 67, 54, 0.3);
        }

        #resetBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(244, 67, 54, 0.4);
        }

        a.download-link {
            display: block;
            margin-top: 8px;
            font-size: 11px;
            text-decoration: none;
            color: #007bff;
            padding: 4px 8px;
            background: #e3f2fd;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        a.download-link:hover {
            background: #bbdefb;
            color: #0056b3;
        }

        #log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #495057;
            min-height: 50px;
            white-space: pre-wrap;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 5px 0;
            padding: 6px 12px;
            background: linear-gradient(45deg, #e3f2fd, #f3e5f5);
            border-radius: 15px;
            font-size: 13px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-number {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
        }

        @media (max-width: 768px) {
            .comparison-layout {
                flex-direction: column;
                height: auto;
                min-height: 400px;
            }

            .group {
                min-height: 300px;
            }

            .container {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                max-height: 400px;
            }

            .item {
                min-height: 280px;
            }

            img {
                height: 120px;
            }

            p {
                font-size: 12px;
                max-height: 60px;
                -webkit-line-clamp: 3;
                line-clamp: 3;
            }

            .filename {
                font-size: 12px;
                min-height: 35px;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            button {
                width: 100%;
                max-width: 300px;
            }

            .stats {
                flex-wrap: wrap;
                gap: 10px;
            }
        }
    </style>
</head>

<body>
    <div class="main-container">
        <h2>OCR匹配下载工具</h2>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-number" id="aCount">0</div>
                <div class="stat-label">A组图片</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="bCount">0</div>
                <div class="stat-label">B组图片</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="matchedCount">0</div>
                <div class="stat-label">已匹配</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="unmatchedCount">0</div>
                <div class="stat-label">未匹配</div>
            </div>
        </div>

        <div class="controls">
            <label
                style="display:flex;align-items:center;gap:8px;padding:6px 12px;background:#fff;border-radius:10px;border:1px solid #e0e0e0;">
                相似度阈值
                <input id="thresholdInput" type="range" min="0" max="1" step="0.01" value="0.75" style="width:160px;">
                <span id="thresholdValue"
                    style="min-width:36px;text-align:right;font-weight:700;color:#667eea;">0.75</span>
            </label>
            <label
                style="display:flex;align-items:center;gap:8px;padding:6px 12px;background:#fff;border-radius:10px;border:1px solid #e0e0e0;">
                QPS限制(每秒请求数)
                <input id="qpsInput" type="range" min="1" max="10" step="1" value="6" style="width:160px;">
                <span id="qpsValue" style="min-width:24px;text-align:right;font-weight:700;color:#9C27B0;">6</span>
            </label>
            <button id="startBtn">🚀 开始识别并自动匹配</button>
            <button id="confirmBtn" disabled>✅ 确认手动匹配</button>
            <button id="forceMatchBtn" disabled>⚠️ 强制匹配</button>
            <button id="batchDownloadBtn">📥 批量单张下载</button>
            <button id="zipDownloadBtn">📦 批量ZIP下载</button>
            <button id="resetBtn">🔄 重置</button>
        </div>

        <div class="comparison-layout">
            <div class="group">
                <h3>📁 A组图片（参考模板）</h3>
                <div class="file-input-section">
                    <input type="file" id="aFiles" multiple accept="image/*" style="display: none;">
                    <button id="selectAImages" class="select-btn">📂 选择A组图片</button>
                    <span id="aFileCount" class="file-count">未选择文件</span>
                </div>
                <div id="aPreview" class="container">
                </div>
            </div>

            <div class="group">
                <h3>🎯 B组图片（需要重命名）</h3>
                <div class="file-input-section">
                    <input type="file" id="bFiles" multiple accept="image/*" style="display: none;">
                    <button id="selectBImages" class="select-btn">📂 选择B组图片</button>
                    <span id="bFileCount" class="file-count">未选择文件</span>
                </div>
                <div id="bPreview" class="container">
                </div>
            </div>
        </div>



        <div id="log"></div>

    </div>
    <script src="https://cdn.jsdelivr.net/npm/string-similarity@4.0.4/umd/string-similarity.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script>
        // ============================================================
        // API 服务器地址配置（自动适配本地和生产环境）
        // ============================================================
        const API_BASE_URL = (() => {
            // 方式1: 如果是从服务器访问（http://或https://），使用相对路径
            if (window.location.protocol === 'http:' || window.location.protocol === 'https:') {
                // 假设前端和后端在同一台服务器上
                const port = window.location.port || (window.location.protocol === 'https:' ? '443' : '80');

                // 如果通过 3000 端口访问（直接访问后端）
                if (port === '3000') {
                    return `${window.location.protocol}//${window.location.hostname}:3000`;
                }

                // 如果通过其他端口访问（如 Nginx 代理），后端在 3000 端口
                return `${window.location.protocol}//${window.location.hostname}:3000`;
            }

            // 方式2: 如果是本地 file:// 打开
            // 默认使用 localhost（本地开发）
            // return 'http://localhost:3000';

            // 如果要连接远程服务器，取消下面这行的注释并修改IP：
            return 'http://117.72.99.159:3000';
        })();

        console.log(`📡 API服务器地址: ${API_BASE_URL}`);

        // ============================================================

        function sleep(ms) {
            return new Promise(r => setTimeout(r, ms))
        }

        async function convertImageToBase64(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement("canvas");
                    canvas.width = img.width;
                    canvas.height = img.height;
                    canvas.getContext("2d").drawImage(img, 0, 0);
                    resolve(canvas.toDataURL("image/jpeg").split(",")[1])
                };
                img.onerror = reject;
                const reader = new FileReader();
                reader.onload = e => img.src = e.target.result;
                reader.readAsDataURL(file)
            })
        }

        async function ocrImage(file, retryCount = 0) {
            const base64 = await convertImageToBase64(file);
            try {
                const res = await fetch(`${API_BASE_URL}/ocr`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ imageBase64: base64 })
                });
                const data = await res.json();

                // 检查是否是QPS限制错误
                if (data.error_code === 18 || data.error_msg?.includes("qps") || data.error_msg?.includes("limit") || data.error_msg?.includes("Open api qps request limit reached")) {
                    if (retryCount < 5) {
                        const waitTime = 5000 * (retryCount + 1); // 5秒、10秒、15秒、20秒、25秒
                        console.log(`QPS限制，等待 ${waitTime / 1000} 秒后重试... (${retryCount + 1}/5)`);
                        await sleep(waitTime);
                        return await ocrImage(file, retryCount + 1);
                    } else {
                        return { text: "QPS限制，请稍后重试", confidence: 0 };
                    }
                }

                const text = data.words_result?.map(w => w.words).join(" ") || "";
                const confidence = data.words_result?.length > 0 ?
                    data.words_result.reduce((sum, w) => sum + (w.probability || 0.8), 0) / data.words_result.length : 0;
                // 如果没有识别到文字，明确标记
                return {
                    text: text || "未识别到文字",
                    confidence: Math.round(confidence * 100)
                };
            } catch (e) {
                if (retryCount < 2) {
                    console.log(`网络错误，重试中... (${retryCount + 1}/2)`);
                    await sleep(300);
                    return await ocrImage(file, retryCount + 1);
                }
                return { text: "识别失败", confidence: 0 };
            }
        }

        // ============================================================
        // 激进并发策略：每个Key独立计时，每秒发2个请求
        // ============================================================
        const KEY_COUNT = 3;  // API Key 数量
        const QPS_PER_KEY = 2;  // 每个Key每秒的请求数
        const TOTAL_QPS = KEY_COUNT * QPS_PER_KEY;  // 总QPS = 6

        // 记录每个批次的发送时间
        const batchTimestamps = [];
        let currentBatchIndex = 0;

        async function takeRateSlot() {
            const now = Date.now();

            // 计算当前应该在第几批（每秒一批，每批6个请求）
            const currentSecond = Math.floor(now / 1000);

            // 清理超过2秒的旧记录
            while (batchTimestamps.length > 0 && now - batchTimestamps[0] > 2000) {
                batchTimestamps.shift();
            }

            // 检查当前秒内是否已经发送了6个请求
            const requestsInCurrentSecond = batchTimestamps.filter(t =>
                Math.floor(t / 1000) === currentSecond
            ).length;

            if (requestsInCurrentSecond < TOTAL_QPS) {
                // 还可以发送
                batchTimestamps.push(now);
                return;
            }

            // 需要等待到下一秒
            const nextSecond = (currentSecond + 1) * 1000;
            const waitTime = nextSecond - now;
            if (waitTime > 0) {
                await sleep(waitTime);
            }

            // 重新尝试
            return takeRateSlot();
        }

        async function runWithConcurrency(tasks, limit, worker) {
            const results = new Array(tasks.length);
            let nextIndex = 0;
            let running = 0;
            return new Promise((resolve) => {
                const launchNext = () => {
                    while (running < limit && nextIndex < tasks.length) {
                        const current = nextIndex++;
                        running++;
                        Promise.resolve(worker(tasks[current], current))
                            .then((res) => { results[current] = res; })
                            .catch(() => { results[current] = undefined; })
                            .finally(() => {
                                running--;
                                if (nextIndex >= tasks.length && running === 0) {
                                    resolve(results);
                                } else {
                                    launchNext();
                                }
                            });
                    }
                };
                launchNext();
            });
        }

        function updateStats() {
            document.getElementById('aCount').textContent = aResults.length;
            document.getElementById('bCount').textContent = bResults.length;
            const matched = bResults.filter(b => b.matched).length;
            const unmatched = bResults.length - matched;
            document.getElementById('matchedCount').textContent = matched;
            document.getElementById('unmatchedCount').textContent = unmatched;
        }

        // 图片预览功能
        function showImagePreview(imageData, type) {
            const modal = document.createElement('div');
            modal.className = 'image-preview-modal';
            modal.onclick = () => closeImagePreview(modal);

            const content = document.createElement('div');
            content.className = 'image-preview-content';
            content.onclick = (e) => e.stopPropagation(); // 阻止事件冒泡

            const img = document.createElement('img');
            img.src = imageData.url;
            img.alt = imageData.file.name;

            const info = document.createElement('div');
            info.className = 'image-preview-info';

            const groupName = type === 'a' ? 'A组（参考模板）' : 'B组（需要重命名）';
            const matchStatus = imageData.matched ? '✅ 已匹配' : '❌ 未匹配';
            const downloadName = imageData.downloadName || imageData.file.name;

            info.innerHTML = `
                <h3>${groupName} - ${imageData.file.name}</h3>
                <p><strong>状态：</strong>${matchStatus}</p>
                <p><strong>尺寸：</strong>${imageData.width} × ${imageData.height}</p>
                <p><strong>OCR文本：</strong>${imageData.text || '未识别'}</p>
                <p><strong>置信度：</strong>${imageData.confidence || 0}%</p>
                <p><strong>重命名：</strong>${downloadName}</p>
                ${imageData.similarity ? `<p><strong>相似度：</strong>${Math.round(imageData.similarity * 100)}%</p>` : ''}
            `;

            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-preview';
            closeBtn.innerHTML = '×';
            closeBtn.onclick = () => closeImagePreview(modal);

            content.appendChild(img);
            content.appendChild(info);
            content.appendChild(closeBtn);
            modal.appendChild(content);
            document.body.appendChild(modal);

            // 添加键盘事件监听
            const handleKeyPress = (e) => {
                if (e.key === 'Escape') {
                    closeImagePreview(modal);
                }
            };
            document.addEventListener('keydown', handleKeyPress);
            modal._keyHandler = handleKeyPress;
        }

        function closeImagePreview(modal) {
            if (modal && modal.parentNode) {
                modal.parentNode.removeChild(modal);
                if (modal._keyHandler) {
                    document.removeEventListener('keydown', modal._keyHandler);
                }
            }
        }

        function renderImages(container, results, type) {
            container.innerHTML = "";

            // 统一的排序逻辑：已匹配的在前，未匹配的在后，按尺寸和名称排序
            results.sort((a, b) => {
                let aMatched = false, bMatched = false;

                if (type === "a") {
                    // A组：检查是否被任何B组图片匹配
                    aMatched = bResults.some(bItem => bItem.matched && bItem.matchedA === a);
                    bMatched = bResults.some(bItem => bItem.matched && bItem.matchedA === b);
                } else {
                    // B组：直接使用matched属性
                    aMatched = a.matched;
                    bMatched = b.matched;
                }

                // 第一优先级：已匹配的在前，未匹配的在后
                if (aMatched && !bMatched) return -1;  // a已匹配 → 排前面
                if (!aMatched && bMatched) return 1;   // a未匹配 → 排后面

                // 第二优先级：按分辨率从小到大排序
                if (a.resolution !== b.resolution) {
                    return a.resolution - b.resolution;
                }

                // 第三优先级：使用downloadName进行排序，如果没有downloadName则使用file.name
                const aName = a.downloadName || a.file.name;
                const bName = b.downloadName || b.file.name;
                const nameComparison = aName.localeCompare(bName);
                if (nameComparison !== 0) {
                    return nameComparison;
                }

                // 第四优先级：按上传顺序排序（保持相对顺序稳定）
                return (a.uploadIndex || 0) - (b.uploadIndex || 0);
            });

            results.forEach(r => {
                const div = document.createElement("div");
                div.classList.add("item");
                div.draggable = false; // 禁用图片项的拖拽，避免与容器拖拽冲突
                div.dataset.type = type;
                div.dataset.index = results.indexOf(r);

                const img = document.createElement("img");
                img.src = r.url;
                img.title = `OCR: ${r.text}\n即将重命名: ${r.downloadName}\n分辨率: ${r.width}x${r.height}\n置信度: ${r.confidence || 0}%`;
                img.ondblclick = (e) => {
                    e.stopPropagation(); // 阻止事件冒泡，避免触发选择事件
                    showImagePreview(r, type);
                };

                const p = document.createElement("p");
                // 显示OCR识别结果，如果为空则显示等待状态
                if (!r.text || r.text === "") {
                    p.textContent = "等待识别...";
                } else {
                    p.textContent = r.text;
                }

                const nameResolutionContainer = document.createElement("div");
                nameResolutionContainer.className = "name-resolution-container";

                const nameSpan = document.createElement("span");
                nameSpan.className = "filename-text";
                nameSpan.textContent = r.downloadName || r.file.name;

                const resolutionSpan = document.createElement("span");
                resolutionSpan.className = "resolution-text";
                resolutionSpan.textContent = `${r.width}x${r.height}`;

                nameResolutionContainer.appendChild(nameSpan);
                nameResolutionContainer.appendChild(resolutionSpan);

                // 修复A组和B组的状态显示
                if (type === "a") {
                    // A组：检查是否被任何B组图片匹配
                    const isMatched = bResults.some(b => b.matched && b.matchedA === r);
                    nameResolutionContainer.classList.add(isMatched ? "matched" : "unmatched");
                } else {
                    // B组：根据是否匹配显示状态
                    nameResolutionContainer.classList.add(r.matched ? "matched" : "unmatched");
                }

                // 添加删除按钮
                const deleteBtn = document.createElement("button");
                deleteBtn.className = "delete-button";
                deleteBtn.innerHTML = "×";
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (type === "a") {
                        const index = aResults.indexOf(r);
                        if (index > -1) {
                            aResults.splice(index, 1);
                            renderImages(document.getElementById("aPreview"), aResults, "a");
                            document.getElementById("aFileCount").textContent = `已选择 ${aResults.length} 张图片`;
                            enableSingleSelect(); // 重新绑定点击事件
                        }
                    } else {
                        const index = bResults.indexOf(r);
                        if (index > -1) {
                            bResults.splice(index, 1);
                            renderImages(document.getElementById("bPreview"), bResults, "b");
                            document.getElementById("bFileCount").textContent = `已选择 ${bResults.length} 张图片`;
                            enableSingleSelect(); // 重新绑定点击事件
                        }
                    }
                    updateStats();
                };
                div.appendChild(deleteBtn);





                div.appendChild(img);
                div.appendChild(p);
                div.appendChild(nameResolutionContainer);

                // 添加尺寸匹配指示器
                if (type === "b" && selectedA) {
                    const sizeMatch = (selectedA.width === r.width && selectedA.height === r.height);
                    const sizeIndicator = document.createElement("div");
                    sizeIndicator.className = "size-match-indicator";
                    sizeIndicator.classList.add(sizeMatch ? "match" : "no-match");
                    sizeIndicator.textContent = sizeMatch ? "尺寸匹配" : "尺寸不符";
                    div.appendChild(sizeIndicator);
                }

                if (r.matched && type === "b") {
                    const a = document.createElement("a");
                    a.href = "#";
                    a.download = r.downloadName || r.file.name;
                    a.textContent = "下载";
                    a.className = "download-link";
                    a.addEventListener("click", (e) => {
                        e.preventDefault();
                        try {
                            // 重新创建 downloadLink，避免 URL 过期
                            const downloadLink = URL.createObjectURL(r.file);
                            const downloadA = document.createElement("a");
                            downloadA.href = downloadLink;
                            downloadA.download = r.downloadName || r.file.name;
                            downloadA.style.display = "none";
                            document.body.appendChild(downloadA);
                            downloadA.click();
                            setTimeout(() => {
                                document.body.removeChild(downloadA);
                                URL.revokeObjectURL(downloadLink);
                            }, 100);
                        } catch (error) {
                            console.error("单张下载失败:", error);
                            alert("下载失败，请重试！");
                        }
                    });
                    div.appendChild(a)
                }

                container.appendChild(div);
                r.domDiv = div;
                r.domP = p;
                r.domNameP = nameResolutionContainer;
            });

        }

        async function handleFiles(inputEl, containerEl, type) {
            if (!inputEl || !inputEl.files) return [];
            let files = Array.from(inputEl.files);

            // 基于现有结果进行追加，而不是每次重置
            const results = (type === "a" ? aResults : bResults).slice();
            const currentMaxIndex = results.length > 0 ? Math.max(...results.map(r => r.uploadIndex || 0)) : -1;

            for (let i = 0; i < files.length; i++) {
                const f = files[i];
                const base64URL = await convertImageToBase64(f);
                // 获取图片分辨率
                const img = new Image();
                await new Promise((resolve) => {
                    img.onload = resolve;
                    img.src = "data:image/jpeg;base64," + base64URL;
                });

                results.push({
                    file: f,
                    url: "data:image/jpeg;base64," + base64URL,
                    text: "",
                    downloadLink: null,
                    downloadName: f.name,
                    matched: false,
                    width: img.width,
                    height: img.height,
                    resolution: img.width * img.height,
                    uploadIndex: currentMaxIndex + i + 1  // 添加上传顺序索引
                })
            }

            // 按分辨率从小到大排序，分辨率相同时按名称排序，再按上传顺序
            results.sort((a, b) => {
                if (a.resolution !== b.resolution) {
                    return a.resolution - b.resolution;
                }
                const nameComparison = a.file.name.localeCompare(b.file.name);
                if (nameComparison !== 0) {
                    return nameComparison;
                }
                return (a.uploadIndex || 0) - (b.uploadIndex || 0);
            });

            // 回写到全局并渲染
            if (type === "a") {
                aResults = results;
            } else {
                bResults = results;
            }

            renderImages(containerEl, results, type);
            updateStats();
            return results
        }

        let aResults = [], bResults = [], selectedA = null, selectedB = null;
        let ocrDoneOnce = false;

        function getCurrentThreshold() {
            const el = document.getElementById("thresholdInput");
            const val = parseFloat(el && el.value ? el.value : "0.5");
            return isNaN(val) ? 0.5 : val;
        }

        function hasValidText(item) {
            return item && item.text && item.text.trim() && item.text !== "识别失败" && item.text !== "未识别到文字";
        }

        function clearPreviousAutoMatches() {
            bResults.forEach(b => {
                if (b.autoMatched) {
                    // release A usage only if no other B points to it
                    const prevA = b.matchedA;
                    b.matched = false;
                    b.downloadLink = null;
                    b.downloadName = b.file.name;
                    b.matchedA = null;
                    b.autoMatched = false;
                    // do not touch manualMatched flag here
                    if (prevA) {
                        const stillUsed = bResults.some(otherB => otherB !== b && otherB.matched && otherB.matchedA === prevA);
                        if (!stillUsed) {
                            prevA.matched = bResults.some(otherB => otherB.matched && otherB.matchedA === prevA);
                        }
                    }
                }
            });
        }

        function recomputeAutoMatchingFromThreshold() {
            if (!ocrDoneOnce) return; // only active after OCR run

            const threshold = getCurrentThreshold();

            // Build a set of A images already occupied by manual matches
            const usedAMatches = new Set();
            bResults.forEach(b => {
                if (b.matched && b.manualMatched && b.matchedA) {
                    usedAMatches.add(b.matchedA);
                }
            });

            // Clear previous auto matches to re-evaluate
            clearPreviousAutoMatches();

            // Re-run auto match for currently unmatched B only
            bResults.forEach(b => {
                if (b.matched) return; // keep manual matches
                if (!hasValidText(b)) return;

                let bestMatch = null;
                let bestSimilarity = 0;

                aResults.forEach(a => {
                    if (usedAMatches.has(a)) return;
                    if (!hasValidText(a)) return;
                    if (!(a.width === b.width && a.height === b.height)) return;

                    const similarity = stringSimilarity.compareTwoStrings(b.text, a.text);
                    if (similarity >= threshold && similarity > bestSimilarity) {
                        bestMatch = a;
                        bestSimilarity = similarity;
                    }
                });

                if (bestMatch) {
                    b.matched = true;
                    b.similarity = bestSimilarity;
                    b.autoMatched = true;
                    b.matchedA = bestMatch;
                    usedAMatches.add(bestMatch);
                    const suffix = b.file.name.split(".").pop();
                    const newName = bestMatch.file.name.split(".")[0] + "." + suffix;
                    const link = URL.createObjectURL(b.file);
                    b.downloadLink = link;
                    b.downloadName = newName;
                }
            });

            // Re-render to reflect new states
            renderImages(document.getElementById("aPreview"), aResults, "a");
            renderImages(document.getElementById("bPreview"), bResults, "b");
            enableSingleSelect();
            updateStats();
        }

        // 文件选择事件
        document.getElementById("aFiles").addEventListener("change", async () => {
            aResults = await handleFiles(document.getElementById("aFiles"), document.getElementById("aPreview"), "a");
            document.getElementById("aFileCount").textContent = `已选择 ${aResults.length} 张图片`;
        });

        document.getElementById("bFiles").addEventListener("change", async () => {
            bResults = await handleFiles(document.getElementById("bFiles"), document.getElementById("bPreview"), "b");
            document.getElementById("bFileCount").textContent = `已选择 ${bResults.length} 张图片`;
        });

        // 选择按钮事件
        document.getElementById("selectAImages").addEventListener("click", () => {
            document.getElementById("aFiles").click();
        });

        document.getElementById("selectBImages").addEventListener("click", () => {
            document.getElementById("bFiles").click();
        });

        // 拖拽上传功能（只用于文件上传，不影响图片匹配）
        function setupDragAndDrop(containerId, inputId, type) {
            const container = document.getElementById(containerId);
            const input = document.getElementById(inputId);

            container.addEventListener('dragover', (e) => {
                // 检查是否是从外部拖拽的文件，并且不是从容器内部拖拽
                if (e.dataTransfer.types.includes('Files') && !e.target.closest('.item')) {
                    e.preventDefault();
                    container.classList.add('drag-over');
                }
            });

            container.addEventListener('dragleave', (e) => {
                // 只有当离开容器本身时才移除样式
                if (!container.contains(e.relatedTarget)) {
                    container.classList.remove('drag-over');
                }
            });

            container.addEventListener('drop', async (e) => {
                e.preventDefault();
                container.classList.remove('drag-over');

                // 检查是否是从外部拖拽的文件，并且不是从容器内部拖拽
                const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
                if (files.length > 0 && !e.target.closest('.item')) {
                    // 创建FileList对象
                    const dataTransfer = new DataTransfer();
                    files.forEach(file => dataTransfer.items.add(file));
                    input.files = dataTransfer.files;

                    // 触发change事件
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                }
            });
        }

        // 设置A组和B组的拖拽上传功能
        setupDragAndDrop('aPreview', 'aFiles', 'a');
        setupDragAndDrop('bPreview', 'bFiles', 'b');


        function enableSingleSelect() {
            aResults.forEach(a => {
                a.domDiv.onclick = () => {
                    selectedA = (selectedA === a) ? null : a;
                    updateSelection()
                }
            });
            bResults.forEach(b => {
                b.domDiv.onclick = () => {
                    selectedB = (selectedB === b) ? null : b;
                    updateSelection()
                }
            });

        }

        function updateSelection() {
            aResults.forEach(a => a.domDiv.classList.toggle("selected", a === selectedA));
            bResults.forEach(b => b.domDiv.classList.toggle("selected", b === selectedB));

            // 无论是否选择A，都重新渲染B组，以动态显示或隐藏尺寸匹配指示器
            renderImages(document.getElementById("bPreview"), bResults, "b");
            // 重新绑定B组图片的点击事件（支持二次点击取消选中）
            bResults.forEach(b => {
                b.domDiv.onclick = () => {
                    selectedB = (selectedB === b) ? null : b;
                    updateSelection()
                }
            });
            // 恢复B组图片的选中状态
            bResults.forEach(b => b.domDiv.classList.toggle("selected", b === selectedB));

            // 更新确认按钮和强制匹配按钮状态（互斥）
            const confirmBtn = document.getElementById("confirmBtn");
            const forceMatchBtn = document.getElementById("forceMatchBtn");

            if (confirmBtn && forceMatchBtn) {
                const hasSelection = selectedA && selectedB;
                const sizeMatch = hasSelection &&
                    selectedA.width === selectedB.width &&
                    selectedA.height === selectedB.height;

                if (hasSelection) {
                    if (sizeMatch) {
                        // 尺寸匹配：启用"确认手动匹配"，禁用"强制匹配"
                        confirmBtn.disabled = false;
                        confirmBtn.style.opacity = "1";
                        forceMatchBtn.disabled = true;
                        forceMatchBtn.style.opacity = "0.5";
                    } else {
                        // 尺寸不匹配：禁用"确认手动匹配"，启用"强制匹配"
                        confirmBtn.disabled = true;
                        confirmBtn.style.opacity = "0.5";
                        forceMatchBtn.disabled = false;
                        forceMatchBtn.style.opacity = "1";
                    }
                } else {
                    // 未选择：两个按钮都禁用
                    confirmBtn.disabled = true;
                    confirmBtn.style.opacity = "0.5";
                    forceMatchBtn.disabled = true;
                    forceMatchBtn.style.opacity = "0.5";
                }
            }
        }

        document.getElementById("startBtn").addEventListener("click", async () => {
            const logEl = document.getElementById("log");
            logEl.textContent = "开始OCR识别...\n注意：免费版API有QPS限制，请耐心等待\n";

            // 只识别还没有OCR结果或上次识别失败/未识别到文字的图片
            let aToProcess = aResults.filter(r => !r.text || r.text === "" || r.text === "识别失败" || r.text === "未识别到文字");
            let bToProcess = bResults.filter(r => !r.text || r.text === "" || r.text === "识别失败" || r.text === "未识别到文字");

            const totalA = aToProcess.length;
            const totalB = bToProcess.length;
            let doneA = 0;
            let doneB = 0;

            if (totalA + totalB > 0) {
                logEl.textContent = `批次识别中 (A:${totalA} B:${totalB})，每秒6张...\n`;
                const allTasks = [
                    ...aToProcess.map(item => ({ group: 'a', item })),
                    ...bToProcess.map(item => ({ group: 'b', item }))
                ];

                // 批次发送策略：每秒发送6个，不等待返回
                const BATCH_SIZE = 6;  // 每批6个（3个Key × 2个请求）
                const BATCH_INTERVAL = 1000;  // 每秒一批

                let batchIndex = 0;
                const startTime = Date.now();

                // 按批次处理
                while (batchIndex * BATCH_SIZE < allTasks.length) {
                    const batchStartIndex = batchIndex * BATCH_SIZE;
                    const batchEndIndex = Math.min(batchStartIndex + BATCH_SIZE, allTasks.length);
                    const batchTasks = allTasks.slice(batchStartIndex, batchEndIndex);

                    // 计算应该在第几秒发送这一批
                    const targetTime = startTime + (batchIndex * BATCH_INTERVAL);
                    const now = Date.now();
                    const waitTime = targetTime - now;

                    // 如果还没到时间，等待
                    if (waitTime > 0) {
                        await sleep(waitTime);
                    }

                    // 同时发送这一批的所有请求（不等待返回）
                    batchTasks.forEach(async (task) => {
                        try {
                            const target = task.item;
                            const result = await ocrImage(target.file);
                            target.text = result.text;
                            target.confidence = result.confidence;
                            if (target.domP) {
                                target.domP.textContent = (target.text && target.text.trim()) ? target.text : "未识别到文字";
                            }
                            if (task.group === 'a') {
                                doneA++;
                            } else {
                                doneB++;
                            }
                            logEl.textContent = `A组进度: ${doneA}/${totalA}  B组进度: ${doneB}/${totalB}\n`;
                        } catch (err) {
                            console.error('识别失败:', err);
                        }
                    });

                    logEl.textContent = `已发送批次 ${batchIndex + 1}/${Math.ceil(allTasks.length / BATCH_SIZE)}，等待结果返回...\nA组进度: ${doneA}/${totalA}  B组进度: ${doneB}/${totalB}\n`;
                    batchIndex++;
                }

                // 等待所有请求完成（给个合理的超时时间）
                const maxWaitTime = Math.ceil(allTasks.length / BATCH_SIZE) * BATCH_INTERVAL + 5000;
                const checkInterval = setInterval(() => {
                    if (doneA + doneB >= allTasks.length) {
                        clearInterval(checkInterval);
                    }
                }, 100);

                // 等待所有任务完成或超时
                await new Promise((resolve) => {
                    const timeout = setTimeout(() => {
                        clearInterval(checkInterval);
                        resolve();
                    }, maxWaitTime);

                    const check = setInterval(() => {
                        if (doneA + doneB >= allTasks.length) {
                            clearTimeout(timeout);
                            clearInterval(check);
                            resolve();
                        }
                    }, 100);
                });
            }

            // 重新渲染以显示置信度
            renderImages(document.getElementById("aPreview"), aResults, "a");
            renderImages(document.getElementById("bPreview"), bResults, "b");

            // 自动匹配：只匹配还没有手动匹配过的B组图片
            const unmatchedB = bResults.filter(b => !b.matched);
            if (unmatchedB.length > 0) {
                logEl.textContent = `自动匹配未匹配的B组图片 (${unmatchedB.length}张)...\n`;

                const threshold = getCurrentThreshold();
                let autoMatchedCount = 0;
                let skippedCount = 0;

                // 用于记录已经被匹配的A组图片，避免重复匹配
                const usedAMatches = new Set();

                unmatchedB.forEach(b => {
                    let bestMatch = null;
                    let bestSimilarity = 0;

                    // 检查B组图片是否OCR识别成功
                    const bHasValidText = b.text && b.text.trim() && b.text !== "识别失败" && b.text !== "未识别到文字";
                    if (!bHasValidText) {
                        skippedCount++;
                        return; // B组图片OCR识别失败，跳过自动匹配
                    }

                    aResults.forEach(a => {
                        // 检查A组图片是否已经被其他B组图片匹配
                        if (usedAMatches.has(a)) return; // A组图片已被使用，跳过

                        // 检查A组图片是否OCR识别成功
                        const aHasValidText = a.text && a.text.trim() && a.text !== "识别失败" && a.text !== "未识别到文字";
                        if (!aHasValidText) return; // A组图片OCR识别失败，跳过

                        // 检查尺寸是否匹配
                        const sizeMatch = (a.width === b.width && a.height === b.height);
                        if (!sizeMatch) return; // 尺寸不匹配则跳过

                        const similarity = stringSimilarity.compareTwoStrings(b.text, a.text);
                        if (similarity >= threshold && similarity > bestSimilarity) {
                            bestMatch = a;
                            bestSimilarity = similarity;
                        }
                    });

                    if (bestMatch) {
                        b.matched = true;
                        b.similarity = bestSimilarity;
                        b.autoMatched = true; // 标记为自动匹配
                        b.matchedA = bestMatch; // 记录匹配的A组图片
                        usedAMatches.add(bestMatch); // 标记A组图片已被使用
                        const a = bestMatch;
                        const suffix = b.file.name.split(".").pop();
                        const newName = a.file.name.split(".")[0] + "." + suffix;
                        const link = URL.createObjectURL(b.file);
                        b.downloadLink = link;
                        b.downloadName = newName;
                        autoMatchedCount++;
                    }
                });

                // 重新渲染以显示匹配质量（会自动按新规则排序）
                renderImages(document.getElementById("aPreview"), aResults, "a");
                renderImages(document.getElementById("bPreview"), bResults, "b");

                const remainingUnmatched = unmatchedB.length - autoMatchedCount - skippedCount;
                let logMessage = `识别完成！自动匹配了 ${autoMatchedCount} 张图片`;
                if (skippedCount > 0) {
                    logMessage += `，跳过了 ${skippedCount} 张OCR识别失败的图片`;
                }
                if (remainingUnmatched > 0) {
                    logMessage += `，还有 ${remainingUnmatched} 张需要手动匹配`;
                }
                logMessage += `。\n已匹配的图片已排在前边，按尺寸从小到大显示。`;
                logEl.textContent = logMessage;
            } else {
                logEl.textContent = "识别完成！所有B组图片都已匹配。";
            }

            enableSingleSelect();
            updateStats();
            ocrDoneOnce = true;
        });

        document.getElementById("confirmBtn").addEventListener("click", () => {
            if (!selectedA || !selectedB) {
                alert("请先选择A组和B组的图片进行匹配！");
                return;
            }

            const a = selectedA, b = selectedB;

            // 检查尺寸是否匹配
            const sizeMatch = (a.width === b.width && a.height === b.height);
            if (!sizeMatch) {
                alert(`尺寸不匹配！\nA组图片: ${a.width}x${a.height}\nB组图片: ${b.width}x${b.height}\n只有同尺寸的图片才能匹配！`);
                return;
            }

            // 如果B组图片已经匹配过，先清除之前的匹配关系
            if (b.matched && b.matchedA) {
                // 清除之前A组图片的匹配状态
                const previousA = b.matchedA;
                // 检查这个A组图片是否还被其他B组图片匹配
                const stillMatched = bResults.some(otherB => otherB.matched && otherB.matchedA === previousA && otherB !== b);
                if (!stillMatched) {
                    // 如果没有其他B组图片匹配这个A组图片，清除A组图片的匹配状态
                    previousA.matched = false;
                }
            }

            const suffix = b.file.name.split(".").pop();
            const newName = a.file.name.split(".")[0] + "." + suffix;
            const link = URL.createObjectURL(b.file);

            // 计算相似度
            const similarity = stringSimilarity.compareTwoStrings(b.text || '', a.text || '');

            // 检查是否有其他B组图片使用了相同的重命名
            const duplicateB = bResults.find(otherB =>
                otherB !== b &&
                otherB.downloadName === newName &&
                otherB.matched
            );

            if (duplicateB) {
                // 如果发现重复名称，说明自动识别错误，重命名为其他名字并归类到未匹配
                const duplicateSuffix = duplicateB.file.name.split(".").pop();
                const duplicateNewName = `unmatched_${Date.now()}_${duplicateB.file.name}`;

                duplicateB.matched = false;
                duplicateB.downloadName = duplicateNewName;
                duplicateB.downloadLink = null;
                duplicateB.matchedA = null;
                duplicateB.autoMatched = false;
                duplicateB.manualMatched = false;

                // 清除对应A组图片的匹配状态
                if (duplicateB.matchedA) {
                    const duplicateA = duplicateB.matchedA;
                    const stillMatched = bResults.some(otherB =>
                        otherB.matched && otherB.matchedA === duplicateA && otherB !== duplicateB
                    );
                    if (!stillMatched) {
                        duplicateA.matched = false;
                    }
                }
            }

            b.downloadLink = link;
            b.downloadName = newName;
            b.matched = true;
            b.similarity = similarity;
            b.manualMatched = true; // 标记为手动匹配
            b.matchedA = a; // 记录匹配的A组图片
            a.matched = true;

            // 重新渲染以显示匹配状态（会自动按新规则排序）
            renderImages(document.getElementById("aPreview"), aResults, "a");
            renderImages(document.getElementById("bPreview"), bResults, "b");

            selectedA = null;
            selectedB = null;
            updateSelection(); // 更新选择状态，清除高亮
            enableSingleSelect(); // 重新绑定点击事件
            updateStats();

            // 更新日志
            const logEl = document.getElementById("log");
            const action = b.autoMatched ? "重新匹配" : "手动匹配";
            let logMessage = `✅ ${action}成功！\nB组: ${b.file.name} → ${newName}\n尺寸: ${a.width}x${a.height}\n相似度: ${Math.round(similarity * 100)}%`;

            if (duplicateB) {
                logMessage += `\n⚠️ 发现重复名称，已重命名并归类到未匹配: ${duplicateB.file.name} → ${duplicateB.downloadName}`;
            }

            logMessage += `\n已匹配的图片已排在前边，按尺寸从小到大显示。`;
            logEl.textContent = logMessage;
        });

        // 强制匹配按钮事件（无视尺寸限制）
        document.getElementById("forceMatchBtn").addEventListener("click", () => {
            if (!selectedA || !selectedB) {
                alert("请先选择A组和B组的图片进行匹配！");
                return;
            }

            const a = selectedA, b = selectedB;

            // 如果B组图片已经匹配过，先清除之前的匹配关系
            if (b.matched && b.matchedA) {
                const previousA = b.matchedA;
                const stillMatched = bResults.some(otherB => otherB.matched && otherB.matchedA === previousA && otherB !== b);
                if (!stillMatched) {
                    previousA.matched = false;
                }
            }

            const suffix = b.file.name.split(".").pop();
            const newName = a.file.name.split(".")[0] + "." + suffix;
            const link = URL.createObjectURL(b.file);

            // 计算相似度
            const similarity = stringSimilarity.compareTwoStrings(b.text || '', a.text || '');

            // 检查是否有其他B组图片使用了相同的重命名
            const duplicateB = bResults.find(otherB =>
                otherB !== b &&
                otherB.downloadName === newName &&
                otherB.matched
            );

            if (duplicateB) {
                const duplicateNewName = `unmatched_${Date.now()}_${duplicateB.file.name}`;
                duplicateB.matched = false;
                duplicateB.downloadName = duplicateNewName;
                duplicateB.downloadLink = null;
                duplicateB.matchedA = null;
                duplicateB.autoMatched = false;
                duplicateB.manualMatched = false;

                if (duplicateB.matchedA) {
                    const duplicateA = duplicateB.matchedA;
                    const stillMatched = bResults.some(otherB =>
                        otherB.matched && otherB.matchedA === duplicateA && otherB !== duplicateB
                    );
                    if (!stillMatched) {
                        duplicateA.matched = false;
                    }
                }
            }

            b.downloadLink = link;
            b.downloadName = newName;
            b.matched = true;
            b.similarity = similarity;
            b.manualMatched = true;
            b.forceMatched = true; // 标记为强制匹配
            b.matchedA = a;
            a.matched = true;

            // 重新渲染
            renderImages(document.getElementById("aPreview"), aResults, "a");
            renderImages(document.getElementById("bPreview"), bResults, "b");

            selectedA = null;
            selectedB = null;
            updateSelection();
            enableSingleSelect();
            updateStats();

            // 更新日志
            const logEl = document.getElementById("log");
            let logMessage = `⚠️ 强制匹配成功！\nB组: ${b.file.name} → ${newName}\nA组尺寸: ${a.width}x${a.height}\nB组尺寸: ${b.width}x${b.height}\n相似度: ${Math.round(similarity * 100)}%`;

            if (duplicateB) {
                logMessage += `\n⚠️ 发现重复名称，已重命名并归类到未匹配: ${duplicateB.file.name} → ${duplicateB.downloadName}`;
            }

            logMessage += `\n\n⚠️ 注意：此图片为强制匹配，尺寸不一致可能导致显示异常！`;
            logMessage += `\n已匹配的图片已排在前边，按尺寸从小到大显示。`;
            logEl.textContent = logMessage;
        });

        document.getElementById("batchDownloadBtn").addEventListener("click", async () => {
            const matchedResults = bResults.filter(b => b.matched);
            if (matchedResults.length === 0) {
                alert("没有已匹配的图片可以下载！");
                return;
            }

            console.log(`开始批量下载 ${matchedResults.length} 张图片...`);

            // 使用延迟下载避免浏览器限制
            for (let i = 0; i < matchedResults.length; i++) {
                const b = matchedResults[i];

                try {
                    // 重新创建 downloadLink，避免 URL 过期
                    const downloadLink = URL.createObjectURL(b.file);

                    const a = document.createElement("a");
                    a.href = downloadLink;
                    a.download = b.downloadName || `matched_${i + 1}.${b.file.name.split('.').pop()}`;
                    a.style.display = "none";
                    document.body.appendChild(a);

                    // 触发下载
                    a.click();

                    // 清理
                    setTimeout(() => {
                        document.body.removeChild(a);
                        URL.revokeObjectURL(downloadLink);
                    }, 100);

                    // 每张图片间隔 200ms，避免浏览器限制
                    if (i < matchedResults.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }

                } catch (error) {
                    console.error(`下载第 ${i + 1} 张图片失败:`, error);
                    // 继续下载其他图片，不中断整个流程
                }
            }

            console.log("批量下载完成！");
        });

        document.getElementById("zipDownloadBtn").addEventListener("click", async () => {
            const matchedResults = bResults.filter(b => b.matched);
            if (matchedResults.length === 0) {
                alert("没有已匹配的图片可以打包下载！");
                return;
            }

            try {
                console.log(`开始打包 ${matchedResults.length} 张图片...`);
                const zip = new JSZip();

                // 添加文件到 ZIP，使用安全的文件名
                matchedResults.forEach((b, i) => {
                    const fileName = b.downloadName || `matched_${i + 1}.${b.file.name.split('.').pop()}`;
                    // 确保文件名安全，移除特殊字符
                    const safeFileName = fileName.replace(/[<>:"/\\|?*]/g, '_');
                    zip.file(safeFileName, b.file);
                });

                console.log("正在生成 ZIP 文件...");
                const content = await zip.generateAsync({
                    type: "blob",
                    compression: "DEFLATE",
                    compressionOptions: { level: 6 }
                });

                // 创建下载链接
                const blobUrl = URL.createObjectURL(content);
                const a = document.createElement("a");
                a.href = blobUrl;
                a.download = `matched_B_group_${new Date().getTime()}.zip`;
                a.style.display = "none";
                document.body.appendChild(a);
                a.click();

                // 清理
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(blobUrl);
                }, 100);

                console.log("ZIP 下载完成！");

            } catch (error) {
                console.error("ZIP 打包失败:", error);
                alert("ZIP 打包失败，请重试！");
            }
        });

        document.getElementById("resetBtn").addEventListener("click", () => {
            aResults = [];
            bResults = [];
            selectedA = null;
            selectedB = null;
            ocrDoneOnce = false;
            document.getElementById("aPreview").innerHTML = "";
            document.getElementById("bPreview").innerHTML = "";
            document.getElementById("log").textContent = "";
            // 清空文件输入与计数
            const aFilesEl = document.getElementById("aFiles");
            const bFilesEl = document.getElementById("bFiles");
            if (aFilesEl) aFilesEl.value = "";
            if (bFilesEl) bFilesEl.value = "";
            const aCountEl = document.getElementById("aFileCount");
            const bCountEl = document.getElementById("bFileCount");
            if (aCountEl) aCountEl.textContent = "未选择文件";
            if (bCountEl) bCountEl.textContent = "未选择文件";
            // 关闭可能打开的预览模态
            const modals = document.querySelectorAll('.image-preview-modal');
            modals.forEach(m => m.parentNode && m.parentNode.removeChild(m));
            // 禁用确认按钮并还原样式
            const confirmBtn = document.getElementById("confirmBtn");
            if (confirmBtn) {
                confirmBtn.disabled = true;
                confirmBtn.style.opacity = "0.5";
            }
            updateStats();
        });

        // 相似度阈值控件联动显示
        (function () {
            const input = document.getElementById("thresholdInput");
            const label = document.getElementById("thresholdValue");
            const sync = () => {
                if (!input || !label) return;
                const v = parseFloat(input.value || "0.5");
                label.textContent = (isNaN(v) ? 0.5 : v).toFixed(2);
            };
            let debounceTimer = null;
            const scheduleRecompute = () => {
                sync();
                if (!ocrDoneOnce) return;
                if (debounceTimer) clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    recomputeAutoMatchingFromThreshold();
                }, 150);
            };
            if (input) {
                input.addEventListener("input", scheduleRecompute);
                input.addEventListener("change", scheduleRecompute);
                sync();
            }
        })();

        // QPS 动态显示与服务器配置同步
        (async function () {
            const input = document.getElementById("qpsInput");
            const label = document.getElementById("qpsValue");
            const sync = () => {
                if (!input || !label) return;
                const v = parseInt(input.value || "6", 10);
                label.textContent = (isNaN(v) || v < 1 ? 6 : v).toString();
            };

            // 从服务器获取配置并更新 QPS 滑块
            try {
                const res = await fetch(`${API_BASE_URL}/config`);
                const config = await res.json();
                if (config.maxQPS) {
                    input.max = config.maxQPS;
                    // 使用服务器配置的 maxQPS 作为默认值（如果服务器支持的话）
                    input.value = Math.min(6, config.maxQPS);
                    sync();
                    console.log(`✅ 已从服务器获取配置: 最大QPS=${config.maxQPS} (${config.totalKeys}个API Key)`);
                }
            } catch (e) {
                console.warn('⚠️ 无法获取服务器配置，使用默认QPS限制=6');
            }

            if (input) {
                input.addEventListener("input", sync);
                input.addEventListener("change", sync);
                sync();
            }
        })();








    </script>
</body>

</html>